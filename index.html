<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Happy Birthday, Mathew!</title>

  <style>
    body {
      margin: 0;
      background: black;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }

    canvas {
      border: 2px solid white;
      width: 100%;
      max-width: 800px;
      touch-action: none;
    }
  </style>
</head>
<body>

<canvas id="game"></canvas>

<script>
/* Kyle 2026. I know this code is pretty messy, it involved a lot of me asking ChatGPT the best ways to implement features and then incrementally copying and pasting. But I learned a lot. */

  function resizeCanvas() {
  // Get device width & height
    canvas.width = window.innerWidth * 0.95;  // 95% of screen width
    canvas.height = window.innerHeight * 0.9; // 90% of screen height
  }

  // Initial resize
  resizeCanvas();
  
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  
  // --------------------
  // Paddle (Player)
  // --------------------
  const paddleWidth = 100;
  const paddleHeight = 12;
  const paddleY = canvas.height - 60;
  let paddleX = (canvas.width - paddleWidth) / 2;

  // Computer paddle (top)
  const cpuPaddleWidth = 100;
  const cpuPaddleHeight = 12;
  const cpuPaddleY = 40;
  let cpuPaddleX = (canvas.width - cpuPaddleWidth) / 2;

  // How fast the computer can move (lower = easier)
  const cpuSpeed = 0.06;

  // Initialize scores
  let playerScore = 0;
  let cpuScore = 0;
  const WIN_SCORE = 9;





  // --------------------
  // Ball
  // --------------------
  const ballRadius = canvas.width * 0.02;
  const ballSize = canvas.width * 0.02; 
  let ballX = canvas.width / 2;
  let ballY = canvas.height / 2;
  let ballVX = 3;
  let ballVY = 3;
  const maxBounceAngle = Math.PI / 3; // 60 degrees
  let ballSpeed = 4;                 // base speed
  const speedIncrease = 0.2;         // per hit




  // --------------------
  // Input (Mouse + Touch)
  // --------------------
  function updatePaddle(x) {
    paddleX = x - paddleWidth / 2;

    // Clamp paddle inside canvas
    if (paddleX < 0) paddleX = 0;
    if (paddleX + paddleWidth > canvas.width) {
      paddleX = canvas.width - paddleWidth;
    }
  }

  canvas.addEventListener("mousemove", (e) => {
    const rect = canvas.getBoundingClientRect();
    updatePaddle(e.clientX - rect.left);
  });

  canvas.addEventListener(
    "touchmove",
    (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      updatePaddle(e.touches[0].clientX - rect.left);
    },
    { passive: false }
  );


  // --------------------
  // Game State
  // --------------------
  let gameState = "start"; // "start", "playing", "win", "lose"

  // --------------------
  // Start game functions
  // --------------------
  function startGame() {
    if (gameState = "playing") return;
    resetBall();
  }
  canvas.addEventListener("click", startGame);
  canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    startGame();
  }, { passive: false });

  // --------------------
  // Ball Image
  // --------------------
  const ballImage = new Image();
  ballImage.src = "Ball.png";






  // --------------------
  // Game Loop
  // --------------------
  function update() {
    //Check if the game is started
    if (gameState !== "playing") return;

    // Move computer paddle toward the ball
    const cpuCenter = cpuPaddleX + cpuPaddleWidth / 2;
    const diff = ballX - cpuCenter;

    cpuPaddleX += diff * cpuSpeed;

    // Clamp inside canvas
    if (cpuPaddleX < 0) cpuPaddleX = 0;
    if (cpuPaddleX + cpuPaddleWidth > canvas.width) {
        cpuPaddleX = canvas.width - cpuPaddleWidth;
    }

    // Move ball
    ballX += ballVX;
    ballY += ballVY;

    // Left / Right wall bounce
    if (ballX - ballRadius < 0 || ballX + ballRadius > canvas.width) {
      ballVX *= -1;
    }

    // Paddle collision (bottom/Player side)
    if (
        ballY + ballRadius > paddleY &&
        ballY + ballRadius < paddleY + paddleHeight &&
        ballX > paddleX &&
        ballX < paddleX + paddleWidth &&
        ballVY > 0
    ) {
        // Where did the ball hit the paddle?
        const paddleCenter = paddleX + paddleWidth / 2;
        const hitOffset = (ballX - paddleCenter) / (paddleWidth / 2);

        // Clamp between -1 and 1
        const clamped = Math.max(-1, Math.min(1, hitOffset));

        // Convert to angle
        const angle = clamped * maxBounceAngle;

        // Increase speed
        ballSpeed += speedIncrease;

        // Set new velocity
        ballVX = ballSpeed * Math.sin(angle);
        ballVY = -ballSpeed * Math.cos(angle);

        // Prevent sticking
        ballY = paddleY - ballRadius;
    }  

    // Computer paddle collision (top)
    if (
        ballY - ballRadius < cpuPaddleY + cpuPaddleHeight &&
        ballY - ballRadius > cpuPaddleY &&
        ballX > cpuPaddleX &&
        ballX < cpuPaddleX + cpuPaddleWidth &&
        ballVY < 0
    ) {
        const paddleCenter = cpuPaddleX + cpuPaddleWidth / 2;
        const hitOffset = (ballX - paddleCenter) / (cpuPaddleWidth / 2);

        const clamped = Math.max(-1, Math.min(1, hitOffset));
        const angle = clamped * maxBounceAngle;

        ballSpeed += speedIncrease;

        ballVX = ballSpeed * Math.sin(angle);
        ballVY = ballSpeed * Math.cos(angle);

        ballY = cpuPaddleY + cpuPaddleHeight + ballRadius;
    }

    
    // Player scores (ball goes past top)
    if (ballY + ballRadius < 0) {
        playerScore++;

        if (playerScore >= WIN_SCORE) {
            gameState = "win";
        } else {
            resetPoint();
        }
    }

    // CPU scores (ball goes past bottom)
    if (ballY - ballRadius > canvas.height) {
        cpuScore++;

        if (cpuScore >= WIN_SCORE) {
            gameState = "lose";
        } else {
            resetPoint();
        }
    }
  }

  function resetBall() {
    ballX = canvas.width / 2;
    ballY = canvas.height / 2;

    ballVX = Math.random() > 0.5 ? 3 : -3;
    ballVY = 3;
  }

  function resetPoint() {
    gameState = "start";

    ballX = canvas.width / 2;
    ballY = canvas.height / 2;

    ballSpeed = 4;

    const angle = (Math.random() * 2 - 1) * maxBounceAngle;
    ballVX = ballSpeed * Math.sin(angle);
    ballVY = Math.random() > 0.5 ? ballSpeed : -ballSpeed;
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Text format
    ctx.fillStyle = "white";
    ctx.font = "20px sans-serif";
    ctx.textAlign = "center";

    // CPU score (top)
    ctx.fillText(cpuScore, canvas.width / 2, 30);

    // Player score (bottom)
    ctx.fillText(playerScore, canvas.width / 2, canvas.height - 20);





    // Paddle
    ctx.fillStyle = "white";
    ctx.fillRect(paddleX, paddleY, paddleWidth, paddleHeight);

    // Computer paddle
    ctx.fillStyle = "white";
    ctx.fillRect(cpuPaddleX, cpuPaddleY, cpuPaddleWidth, cpuPaddleHeight);

    // Ball
    if (ballImage.complete) {
        ctx.drawImage(
            ballImage,
            ballX - ballSize / 2,
            ballY - ballSize / 2,
            ballSize,
            ballSize
        );
    }
    
    // Draw Overlays
    if (gameState === "start") {
        drawOverlay("Tap to Start", "First to score 9 wins (Best of 17)");
    }

    if (gameState === "win") {
        drawOverlay("ðŸŽ‰ You Win!", "Happy 17th Birthday, Mathew!");
    }

    if (gameState === "lose") {
        drawOverlay("ðŸ˜ž Game Over", "No presents for Mathew...");
    }
    
    //If the game isn't started, draw the Intro overlay
/*    if (!gameStarted) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "white";
        ctx.textAlign = "center";

        ctx.font = "32px sans-serif";
        ctx.fillText("Tap to Start", canvas.width / 2, canvas.height / 2 - 40 );

        ctx.font = "16px sans-serif";
        ctx.fillText(
            "Move paddle left and right",
        canvas.width / 2,
        canvas.height / 2 + 50);

        ctx.font = "12 px sans-serif";
        ctx.fillText(
            "First to score 9 wins (Best of 17)",
        canvas.width / 2,
        canvas.height / 2 + 70);
    }*/

    requestAnimationFrame(loop);
  }



    //Define overlay formatting
    function drawOverlay(title, subtitle = "") {
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "white";
        ctx.textAlign = "center";

        ctx.font = "36px sans-serif";
        ctx.fillText(title, canvas.width / 2, canvas.height / 2 - 40);

        if (subtitle) {
            ctx.font = "18px sans-serif";
            ctx.fillText(subtitle, canvas.width / 2, canvas.height / 2 + 50);
        }
    }



  function loop() {
    update();
    draw();
  }

  loop();
</script>

</body>
</html>






